# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strong
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/qo/all/qo.rbi
#
# qo-8951ce899559
module Qo
  extend Qo::Exceptions
  extend Qo::PublicApi
end
module Qo::Exceptions
end
module Qo::PublicApi
  def [](*array_matchers, **keyword_matchers); end
  def and(*array_matchers, **keyword_matchers); end
  def case(value, destructure: nil, &fn); end
  def create_branch(name:, precondition: nil, extractor: nil, destructure: nil, default: nil); end
  def create_matcher(type, array_matchers, keyword_matchers); end
  def create_pattern_match(branches:); end
  def match(destructure: nil, &fn); end
  def not(*array_matchers, **keyword_matchers); end
  def or(*array_matchers, **keyword_matchers); end
  def result_case(target, destructure: nil, &fn); end
  def result_match(destructure: nil, &fn); end
  include Qo::Exceptions
end
module Qo::Destructurers
end
class Qo::Destructurers::Destructurer
  def argument_names; end
  def call(target); end
  def destructure?; end
  def destructure_values(target); end
  def initialize(destructure:, &function); end
end
module Qo::Matchers
end
class Qo::Matchers::Matcher
  def ===(target); end
  def [](target); end
  def array_call(target); end
  def call(target); end
  def case_match?(target, matcher); end
  def combined_check(*checks); end
  def hash_case_match?(target, match_key, matcher); end
  def hash_method_case_match?(target, match_property, matcher); end
  def hash_method_predicate_match?(target, match_key, match_predicate); end
  def hash_recurse(target, matcher); end
  def initialize(type, array_matchers = nil, keyword_matchers = nil); end
  def keyword_call(target); end
  def match?(target); end
  def match_hash_value?(target, match_key, matcher); end
  def match_object_value?(target, match_property, matcher); end
  def match_value?(target, matcher); end
  def match_with(collection, &fn); end
  def method_matches?(target, matcher); end
  def method_send(target, matcher); end
  def to_proc; end
end
module Qo::Branches
end
class Qo::Branches::Branch
  def create_matcher(conditions, destructure: nil, &function); end
  def default?; end
  def initialize(name:, precondition: nil, extractor: nil, destructure: nil, default: nil); end
  def name; end
  def self.create(name:, precondition: nil, extractor: nil, destructure: nil, default: nil); end
end
class Qo::Branches::WhenBranch < Qo::Branches::Branch
  def initialize(destructure: nil); end
end
class Qo::Branches::ElseBranch < Qo::Branches::Branch
  def initialize(destructure: nil); end
end
class Qo::Branches::SuccessBranch < Qo::Branches::Branch
  def initialize(destructure: nil); end
end
class Qo::Branches::ErrorBranch < Qo::Branches::Branch
  def initialize(destructure: nil); end
end
class Qo::Branches::FailureBranch < Qo::Branches::Branch
  def initialize(destructure: nil); end
end
class Qo::Branches::MonadicWhenBranch < Qo::Branches::Branch
  def initialize(destructure: nil, extractor: nil); end
end
class Qo::Branches::MonadicElseBranch < Qo::Branches::Branch
  def initialize(destructure: nil, extractor: nil); end
end
module Qo::PatternMatchers
end
module Qo::PatternMatchers::Branching
  def self.included(base); end
end
module Qo::PatternMatchers::Branching::ClassMethods
  def register_branch(branch); end
end
class Qo::PatternMatchers::PatternMatch
  def ===(value); end
  def [](value); end
  def call(value); end
  def else(*conditions, **keyword_conditions, &function); end
  def initialize(destructure: nil, &fn); end
  def self.create(branches: nil); end
  def self.mixin(destructure: nil, as: nil); end
  def to_proc; end
  def when(*conditions, **keyword_conditions, &function); end
  extend Qo::PatternMatchers::Branching::ClassMethods
  include Qo::PatternMatchers::Branching
end
class Qo::PatternMatchers::ResultPatternMatch < Qo::PatternMatchers::PatternMatch
  def failure(*conditions, **keyword_conditions, &function); end
  def initialize(destructure: nil); end
  def success(*conditions, **keyword_conditions, &function); end
end
